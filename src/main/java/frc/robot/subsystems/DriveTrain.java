// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import frc.robot.commands.*;

import com.revrobotics.CANSparkMax.IdleMode;

import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.motorcontrol.MotorController;
import frc.robot.hardware.WL_Spark;
import frc.robot.Constants;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DriveTrain extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WL_Spark lDM1;
private WL_Spark lDM2;
private WL_Spark rDM1;
private WL_Spark rDM2;

private double wheelDiameter = 8; // in inches
private double gearRatio = 12.75; // Motor to wheel ratio
private double teleopPower = .40; 

private double lDM1Power;
private double lDM2Power;
private double rDM1Power;
private double rDM2Power;

public final double kp_driveStraightGyro = 0.006;


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    /**
    *
    */
    public DriveTrain() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
lDM1 = new WL_Spark(Constants.CANID.lDM1,WL_Spark.MotorType.kBrushless);
 lDM1.setInverted(false);
 lDM1.setIdleMode(IdleMode.kBrake);

lDM2 = new WL_Spark(Constants.CANID.lDM2,WL_Spark.MotorType.kBrushless);
 lDM2.setInverted(false);
 lDM2.setIdleMode(IdleMode.kBrake);

rDM1 = new WL_Spark(Constants.CANID.rDM1,WL_Spark.MotorType.kBrushless);
 rDM1.setInverted(true);
 rDM1.setIdleMode(IdleMode.kBrake);

rDM2 = new WL_Spark(Constants.CANID.rDM2,WL_Spark.MotorType.kBrushless);
 rDM2.setInverted(true);
 rDM2.setIdleMode(IdleMode.kBrake);


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.


    



    public void CMDteleOp(XboxController driveController) {
        doDrive(-1 *driveController.getLeftY(), driveController.getLeftX(), driveController.getRightX(), teleopPower);

    }

    public void doDrive(double drive, double strafe, double turn, double speed) {
        double Drive = drive*speed;
        double Strafe = strafe*speed;
        double Turn = turn*speed;


        lDM1Power = Drive + Strafe + Turn;
        rDM1Power = Drive - Strafe - Turn;
        lDM2Power = Drive - Strafe + Turn;
        rDM2Power = Drive + Strafe - Turn;
        scale();
        SetMotorPower();

    }


    public double getMaxValue() {
        double Max = -1;
        if(Math.abs(lDM1Power) > Max) {
            Max = Math.abs(lDM1Power);
        }
        if(Math.abs(lDM2Power) > Max) {
            Max = Math.abs(lDM2Power);
        }
        if(Math.abs(rDM1Power) > Max) {
            Max = Math.abs(rDM1Power);
        }
        if(Math.abs(rDM2Power) > Max) {
            Max = Math.abs(rDM2Power);
        }
        return Max;
    }
    


    public void scale() {
        double Max = getMaxValue();
        if(Max > 1) {


            lDM1Power = lDM1Power / Max;
            lDM2Power = lDM2Power / Max;
            rDM1Power = rDM1Power / Max;
            rDM2Power = rDM2Power / Max;
        }
    }


    public void SetMotorPower(){
        lDM1.set(lDM1Power);
        lDM2.set(lDM2Power);
        rDM1.set(rDM1Power);
        rDM2.set(rDM2Power);
    }


    public void StopDrive(){
        lDM1.set (0);
        lDM2.set (0);
        rDM1.set (0);
        rDM2.set (0);
    }

    public void resetEncoders(){
        lDM1.resetEncoder();
        lDM2.resetEncoder();
        rDM1.resetEncoder();
        rDM2.resetEncoder();
    }
    
    public double getDistanceTraveledInches(){
        double motorAverageRotations = (lDM1.getPositionABS() + lDM2.getPositionABS() + rDM1.getPositionABS() + rDM2.getPositionABS())/4;
        return (motorAverageRotations * wheelDiameter * Math.PI) / gearRatio; 
    }
}

