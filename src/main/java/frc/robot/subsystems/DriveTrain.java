package frc.robot.subsystems;

import frc.robot.commands.*;

import com.revrobotics.CANSparkMax.IdleMode;

import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj2.command.button.CommandXboxController;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.motorcontrol.MotorController;
import frc.robot.hardware.WL_Spark;
import frc.robot.CommonLogic;
import frc.robot.Constants;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.RobotMath;

/**
 *
 */
public class DriveTrain extends SubsystemBase {

    private WL_Spark lDM1;
    private WL_Spark lDM2;
    private WL_Spark rDM1;
    private WL_Spark rDM2;

    private double wheelDiameter = 8; // in inches
    private double gearRatio = 12.75; // Motor to wheel ratio
    private double teleopPower = .40;

    private double lDM1Power;
    private double lDM2Power;
    private double rDM1Power;
    private double rDM2Power;

    private final double maxrpn = 5676;

    public final double kp_driveStraightGyro = 0.006;

    private double joyDeadBand = 0.03;

    /**
    *
    */
    public DriveTrain() {

        lDM1 = new WL_Spark(Constants.CANID.lDM1, WL_Spark.MotorType.kBrushless);
        lDM1.restoreFactoryDefaults();
        lDM1.setInverted(false);
        setSparkParms(lDM1);

        lDM2 = new WL_Spark(Constants.CANID.lDM2, WL_Spark.MotorType.kBrushless);
        lDM2.restoreFactoryDefaults();
        lDM2.setInverted(false);
        setSparkParms(lDM2);

        rDM1 = new WL_Spark(Constants.CANID.rDM1, WL_Spark.MotorType.kBrushless);
        rDM1.restoreFactoryDefaults();
        rDM1.setInverted(true);
        setSparkParms(rDM1);

        rDM2 = new WL_Spark(Constants.CANID.rDM2, WL_Spark.MotorType.kBrushless);
        rDM2.restoreFactoryDefaults();
        rDM2.setInverted(true);
        setSparkParms(rDM2);

    }

    private void setSparkParms(WL_Spark wls) {
        // set Spark Max params for all 4 sparks to be the same and burn them in
        // This is good practice because if you brown out they can return to default
        // or if you replace one mid comp then you do not have to worry about forgetting
        // to
        // update them via the RevClient.

        wls.setSmartCurrentLimit(40);
        wls.setIdleMode(IdleMode.kBrake);
        wls.burnFlash();

    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void CMDteleOp(CommandXboxController driveController) {
        doDrive(-1 * CommonLogic.joyDeadBand(driveController.getLeftY(), joyDeadBand),
                CommonLogic.joyDeadBand(driveController.getLeftX(), joyDeadBand),
                CommonLogic.joyDeadBand(driveController.getRightX(), joyDeadBand), teleopPower);

    }

    public void doDrive(double drive, double strafe, double turn, double speed) {
        double Drive = drive * speed;
        double Strafe = strafe * speed;
        double Turn = turn * speed;

        lDM1Power = Drive + Strafe + Turn;
        rDM1Power = Drive - Strafe - Turn;
        lDM2Power = Drive - Strafe + Turn;
        rDM2Power = Drive + Strafe - Turn;
        scale();
        SetMotorPower();
        System.err.print(lDM1Power);
    }

    public double getMaxValue() {
        double Max = -1;
        if (Math.abs(lDM1Power) > Max) {
            Max = Math.abs(lDM1Power);
        }
        if (Math.abs(lDM2Power) > Max) {
            Max = Math.abs(lDM2Power);
        }
        if (Math.abs(rDM1Power) > Max) {
            Max = Math.abs(rDM1Power);
        }
        if (Math.abs(rDM2Power) > Max) {
            Max = Math.abs(rDM2Power);
        }
        return Max;
    }

    public void scale() {
        double Max = getMaxValue();
        if (Max > 1) {

            lDM1Power = lDM1Power / Max;
            lDM2Power = lDM2Power / Max;
            rDM1Power = rDM1Power / Max;
            rDM2Power = rDM2Power / Max;
        }
    }

    public void SetMotorPower() {
        lDM1.set(lDM1Power);
        lDM2.set(lDM2Power);
        rDM1.set(rDM1Power);
        rDM2.set(rDM2Power);

    }

    public void StopDrive() {
        lDM1.set(0);
        lDM2.set(0);
        rDM1.set(0);
        rDM2.set(0);
    }

    public void resetEncoders() {
        lDM1.resetEncoder();
        lDM2.resetEncoder();
        rDM1.resetEncoder();
        rDM2.resetEncoder();
    }

    public double getDistanceTraveledInches() {
        double motorAverageRotations = (lDM1.getPositionABS() + lDM2.getPositionABS() + rDM1.getPositionABS()
                + rDM2.getPositionABS()) / 4;
        return (motorAverageRotations * wheelDiameter * Math.PI) / gearRatio;
    }

    public void activeBrake(double power) {

        lDM1.set(RobotMath.goToPos(lDM1.getPosition(), 0, 0.1, power));
        lDM2.set(RobotMath.goToPos(lDM2.getPosition(), 0, 0.1, power));
        rDM1.set(RobotMath.goToPos(rDM1.getPosition(), 0, 0.1, power));
        rDM2.set(RobotMath.goToPos(rDM2.getPosition(), 0, 0.1, power));
    }

    private double powerToRPM(double pwr) {
        return (maxrpn * pwr);
    }
}
